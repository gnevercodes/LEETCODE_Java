# ðŸ§  DSA Pattern â†’ Data Structure Mapping Guide

> Goal: Identify the correct data structure quickly during problem solving.

---

# 1ï¸âƒ£ Two Pointers

Used For:

- Sorted arrays
- Palindromes
- Pair problems

Use:

- Array
- String

Example:

- Two Sum (sorted)
- Remove duplicates

---

# 2ï¸âƒ£ Sliding Window

Used For:

- Subarray
- Substring
- Fixed or variable window

Use:

- Array
- String
- HashMap (for frequency)

Example:

- Longest substring without repeating characters
- Max sum subarray

---

# 3ï¸âƒ£ Hashing Pattern

Used For:

- Fast lookup
- Frequency counting
- Detect duplicates

Use:

- HashMap
- HashSet

Example:

- Two Sum
- Anagram check
- Contains duplicate

---

# 4ï¸âƒ£ Stack Pattern

Used For:

- Parentheses
- Next greater element
- Monotonic stack

Use:

- Stack
- ArrayDeque

Example:

- Valid parentheses
- Daily temperatures

---

# 5ï¸âƒ£ Queue / BFS Pattern

Used For:

- Level order traversal
- Shortest path (unweighted)
- Graph traversal

Use:

- Queue
- LinkedList
- ArrayDeque

Example:

- Binary tree level order
- Rotting oranges

---

# 6ï¸âƒ£ Binary Search Pattern

Used For:

- Sorted arrays
- Search space reduction
- Binary search on answer

Use:

- Array

Example:

- Search in rotated sorted array
- Find peak element

---

# 7ï¸âƒ£ Tree DFS Pattern

Used For:

- Recursive tree problems
- Path sums
- Height/diameter

Use:

- Binary Tree
- Recursion

Example:

- Maximum depth
- Validate BST

---

# 8ï¸âƒ£ Heap / Priority Queue Pattern

Used For:

- Top K problems
- Merge K lists
- Scheduling

Use:

- PriorityQueue

Example:

- Kth largest element
- Top K frequent elements

---

# 9ï¸âƒ£ Graph DFS/BFS Pattern

Used For:

- Connected components
- Cycle detection
- Islands

Use:

- Adjacency List
- HashSet (visited)
- Queue / Recursion

Example:

- Number of islands
- Course schedule

---

# ðŸ”Ÿ Backtracking Pattern

Used For:

- Subsets
- Permutations
- Combinations

Use:

- Recursion
- List

Example:

- Subsets
- N-Queens

---

# 1ï¸âƒ£1ï¸âƒ£ Dynamic Programming Pattern

Used For:

- Overlapping subproblems
- Optimization problems

Use:

- Array
- HashMap (memoization)

Example:

- Fibonacci
- Climbing stairs
- 0/1 Knapsack

---

# ðŸŽ¯ Quick Pattern Recognition Rule

If you see:

- â€œLongest substringâ€ â†’ Sliding Window
- â€œTop Kâ€ â†’ Heap
- â€œSorted arrayâ€ â†’ Binary Search / Two Pointers
- â€œLevelsâ€ â†’ BFS
- â€œNo duplicatesâ€ â†’ HashSet
- â€œFrequency countâ€ â†’ HashMap
- â€œTree heightâ€ â†’ DFS

---

# ðŸš€ Final Interview Strategy

When reading a problem:

1. Identify keywords
2. Match pattern
3. Choose data structure
4. Write clean solution

Pattern > Memorizing 150 problems.
